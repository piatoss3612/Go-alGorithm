# Go: 백준 문제풀이 키워드

---

### 1001~2000

- `bj1003`: 다이나믹 프로그래밍 - 피보나치 수열이라 생각보다 간단하다
- `bj1005`: 다이나믹 프로그래밍, 위상 정렬
- `bj1010`: 다이나믹 프로그래밍 - 미리 모든 경우의 값을 구해놓고 해당하는 값을 찾는 것이 빠르다
- `bj1011`: 제곱근
- `bj1012`: 그래프 탐색
- `bj1021`: 자료 구조 - 덱
- `bj1026`: a와 b를 정렬, (a의 가장 작은 수 \* b의 가장 큰 수)를 반복하면 최솟값을 구할 수 있다
- `bj1037`: 정수론 - 약수들 중 가장 작은 수와 가장 큰 수의 곱이 원래 수 N
- `bj1038`: 브루트포스 알고리즘 - 큐 사용하기
- `bj1057`: 브루트포스 알고리즘
- `bj1064`: 기하학 - 피타고라스 정리
- `bj1068`: 그래프 탐색 - 너비 우선 탐색
- `bj1072`: 이분 탐색 - Z가 99 이상인 경우 더이상 커질 수 없으므로 이를 제외하고 탐색한다
- `bj1074`: 분할 정복
- `bj1075`
- `bj1092`: 그리디 알고리즘
- `bj1094`
- `bj1100`: 배열, 슬라이스, strings 패키지 - 문자열 분할
- `bj1106`: 다이나믹 프로그래밍 - '적어도'라는 표현을 사용하므로 초과되는 경우의 수도 고려해야 한다
- `bj1107`: 브루트포스 알고리즘
- `bj1110`: 반복문
- `bj1149`: 다이나믹 프로그래밍
- `bj1152`: strings 패키지 - Split(), TrimSpace()
- `bj1153`: 에라토스테네스의 체
- `bj1157`
- `bj1167`: 그래프 탐색, 깊이 우선 탐색
- `bj1174`: 브루트포스 알고리즘 - 1038번과 유사
- `bj1181`: sort 패키지 - Slice() 함수의 두번째 인수로 커스텀 정렬 함수 리터럴
- `bj1182`: 백트래킹, 브루트포스 알고리즘
- `bj1188`: 유클리드 호제법
- `bj1197`: 최소 신장 트리 - 크루스칼 알고리즘
- `bj1205`: 조건문을 잘 활용하자
- `bj1225`: 반복문, strconv 패키지 - string(byte타입)을 정수로 변환
- `bj1238`: 다익스트라
- `bj1240`: 그래프 탐색 - 깊이 우선 탐색
- `bj1256`: 다이나믹 프로그래밍, k번째 문자열을 구하는 문제: 건너뛰는 과정이 중요!
- `bj1253`: 두 포인터
- `bj1259`
- `bj1260`: 깊이 우선 탐색, 너비 우선 탐색 - 정점 번호가 작은 것을 먼저 방문한다는 조건에 주의
- `bj1267`
- `bj1271`: math/big 패키지 - big numbers
- `bj1275`: 세그먼트 트리
- `bj1284`: 포인터 슬라이스, bufio 패키지 - 스캐너
- `bj1297`: 피타고라스의 정리
- `bj1300`: 이분 탐색
- `bj1309`: 다이나믹 프로그래밍 - dp[i] = dp[i-1]\*2 + dp[i-2]
- `bj1315`: 다이나믹 프로그래밍 - 맵
- `bj1325`: 그래프 탐색 - 깊이 우선 탐색
- `bj1339`: 그리디 알고리즘
- `bj1343`: strings 패키지 - Contains()로 확인하고 ReplaceAll()로 변환
- `bj1354`: 다이나믹 프로그래밍
- `bj1357`: strings 패키지 - Builder 타입으로 문자열 역순으로 붙이기
- `bj1365`: 이분 탐색, LIS
- `bj1371`: ioutil 패키지를 사용해 한 번에 읽은 뒤에 쪼개기
- `bj1374`: 그리디 알고리즘 - 우선순위 큐
- `bj1377`: 버블 정렬, stable sort
- `bj1389`: 그래프 탐색, 너비 우선 탐색 - 플로이드 와샬을 알면 더 쉽게 풀 수 있는 문제인 것 같다
- `bj1439`: strings 패키지 - builder 타입
- `bj1448`: 그리디 알고리즘 - 삼각형의 가장 큰 변의 길이 < 나머지 변의 길이의 합인데 모든 경우를 구하려면 시간초과 발생, n항 < n-1항 + n-2 항인 경우만 탐색하는 것이 최적해
- `bj1449`: 그리디 알고리즘 - 오름차 순으로 정렬
- `bj1453`
- `bj1461`: 그리디 알고리즘
- `bj1463`: 다이나믹 프로그래밍 - 분할 & 정복이라는 것은 알고 있지만, 아직은 너무 어려운듯
- `bj1475`: 0부터 9까지의 값이 반복되므로 배열의 인덱스를 활용하여 해당 인덱스의 값을 증가
- `bj1476`: 15의 배수에 e를 더한 값을 연도로 가정하고 반복하면 빠르게 최솟값을 찾을 수 있다
- `bj1484`: 두 포인터
- `bj1495`: 다이나믹 프로그래밍
- `bj1509`: 다이나믹 프로그래밍
- `bj1517`: 분할 정복, 병합 정렬
- `bj1520`: 다이나믹 프로그래밍
- `bj1541`: 그리디 알고리즘
- `bj1547`: bufio 패키지 - 스캐너, strings 패키지 - Split(), 포인터 변수
- `bj1561`: 다이나믹 프로그래밍, 위상 정렬
- `bj1613`: 플로이드 와샬 알고리즘
- `bj1620`: 자료 구조 - 맵
- `bj1629`: 분할 정복 - 거듭 제곱
- `bj1644`: 두 포인터, 에라토스테네스의 체
- `bj1647`: 최소 신장 트리 - 크루스칼 알고리즘
- `bj1654`: 이분탐색, 시작을 0으로 시작하면 **런타임 에러(DivideByZero)** 발생
- `bj1655`: 우선순위 큐, 중앙값
- `bj1660`: 다이나믹 프로그래밍
- `bj1662`: 스택, 재귀
- `bj1670`: 다이나믹 프로그래밍
- `bj1676`: 끝에 0이 온다는 것은 10으로 나누어 떨어진다는 것. 2와 5의 개수를 구해서 작은 것을 출력하면 0의 개수를 구할 수 있다
- `bj1697`: 그래프 이론 - 깊이 우선 탐색
- `bj1699`: 다이나믹 프로그래밍
- `bj1715`: 그리디 알고리즘 - 자료구조: 힙
- `bj1719`: 플로이드 와샬 알고리즘
- `bj1725`: 분할 정복
- `bj1735`: 정수론 - 최대공약수
- `bj1744`: 그리디 알고리즘
- `bj1753`: 다익스트라
- `bj1756`: 백트래킹
- `bj1758`: 그리디 알고리즘 - 내림차순으로 정렬하면 최적해를 구할 수 있다
- `bj1764`: 단일 for 반복문 내에서 if문으로 분기
- `bj1766`: 위상 정렬, 최소 힙(우선순위 큐)
- `bj1769`: 백만 자리의 숫자를 처리하는 방법 필요 -> 처음에만 바이트 타입 슬라이스로 연산
- `bj1780`: 분할 정복
- `bj1781`: 그리디 알고리즘, 우선순위 큐
- `bj1788`: 다이나믹 프로그래밍 - n이 음수인데 짝수인 경우만 결과가 음수이다
- `bj1789`: 그리디 알고리즘 - 가장 작은 수 ~ 2를 곱했을 때 남은 수보다 크거나 같아졌을 때 까지
- `bj1806`: 두 포인터
- `bj1850`: 정수론
- `bj1874`: 자료구조 - 스택
- `bj1904`: 다이나믹 프로그래밍 - dp[i] = (dp[i - 1] + dp[i - 2]) % 15746
- `bj1912`: 연속된다는 것은 부분적으로도 연속한다는 의미
- `bj1915`: 다이나믹 프로그래밍
- `bj1916`: 다익스트라
- `bj1920`: 슬라이스를 사용하면 시간 초과, 맵을 사용해야 빠르다
- `bj1922`: 최소 신장 트리
- `bj1927`: 자료 구조 - 최소 힙
- `bj1929`: 소수 판별, m이 1일 경우 1은 소수가 아니므로 2부터 판별 시작
- `bj1931`: 그리디 알고리즘 - 끝나는 시간을 오름차순으로 정렬하면 최적해를 빠르게 찾을 수 있다
- `bj1932`: 다이나믹 프로그래밍 - 위에서부터 차례대로 누적되는 합의 최댓값을 구하면 된다
- `bj1934`: 최대공약수, 최소공배수
- `bj1937`: 다이나믹 프로그래밍, 깊이 우선 탐색
- `bj1956`: 플로이드 와샬 알고리즘
- `bj1964`: 계차수열
- `bj1965`: 다이나믹 프로그래밍
- `bj1966`: 중요도에 따라 정렬하는 과정, 인덱스의 변화, 그리고 인쇄되는 순서를 처음부터 모두 계산하였다
- `bj1967`: 깊이 우선 탐색
- `bj1978`: 소수를 판별하기 위해 나누는 수를 제곱근 이하로 하면 훨씬 빠르다
- `bj1987`: 깊이 우선 탐색, 백트래킹 - 알파벳은 26개로 한정된 숫자. 따라서 map을 사용하는 것은 시간 낭비(3044ms -> 568ms)
- `bj1990`: 소수 판정, 팰린드롬 수 - 최적화 필요
- `bj1991`: 트리 - 전위 순회, 중위 순회, 후위 순회
- `bj1992`: 분할 정복
